# !/usr/bin/env python3
import datetime
import logging
import os
import sys
import time
import traceback
from http.server import BaseHTTPRequestHandler, HTTPServer

logging.basicConfig(format='%(message)s',
                    level=logging.INFO)


def import_all_paths():
    realpath = os.path.realpath(__file__)
    # print("os.path.realpath({})={}".format(__file__,realpath)`)
    dirname = os.path.dirname(realpath)
    # print("os.path.dirname({})={}".format(realpath,dirname))
    dirname_list = dirname.split('/')
    # print(dirname_list)
    for index in range(len(dirname_list)):
        module_path = '/'.join(dirname_list[:index])
        # print("module_path={}".format(module_path))
        try:
            sys.path.append(module_path)
        except:
            # print("Invalid module path {}".format(module_path))
            pass


import_all_paths()


class WebServer(BaseHTTPRequestHandler):
    def do_HEAD(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()

    def do_GET(self):
        self.respond({'status': 200})

    def handle_http(self, status_code, path):
        self.send_response(status_code)
        self.send_header('Content-type', 'text/html')
        self.end_headers()
        content = '''
        <html>
        </html>
        '''
        try:
            with open(Displayer.html_filename, "r", encoding='utf-8') as f:
                content = f.read()
        except FileNotFoundError:
            logging.info("File {} not found yet..".format(Displayer.html_filename))
        return bytes(content, 'UTF-8')

    def respond(self, opts):
        response = self.handle_http(opts['status'], self.path)
        self.wfile.write(response)


class Displayer():
    """
    This class runs a HTTP webserver and renders a html file generated by plotter.
    """

    html_filename = None

    def __init__(self):
        """
        Initialize the class instance variables.
        """
        self.ip_address_of_host = 'localhost'
        self.port_number_of_host = 8888
        self.load_environment_variables()

    def load_environment_variables(self):
        """
        Load environment variables.
        :return:
        """
        while not self.html_filename:
            time.sleep(1)
            Displayer.html_filename = os.getenv("html_filename_key",
                                                default=None)
            self.ip_address_of_host = os.getenv("ip_address_of_host_key",
                                                default='0.0.0.0')
            self.port_number_of_host = int(os.getenv("port_number_of_host_key",
                                                     default='8888'))

        logging.info("html_filename={},\n"
                      "ip_address_of_host={},\n"
                      "port_number_of_host={},\n"
                      .format(Displayer.html_filename,
                              self.ip_address_of_host,
                              self.port_number_of_host,
                              ))

    def cleanup(self):
        pass

    def perform_job(self):
        while True:
            server_class = HTTPServer
            httpd = server_class((self.ip_address_of_host, self.port_number_of_host), WebServer)
            logging.info(time.asctime(), 'Server Starts - %s:%s' % (self.ip_address_of_host, self.port_number_of_host))
            try:
                httpd.serve_forever()
            except KeyboardInterrupt:
                pass
            httpd.server_close()
            logging.info(time.asctime(), 'Server Stops - %s:%s' % (self.ip_address_of_host, self.port_number_of_host))


if __name__ == '__main__':
    displayer = Displayer()
    try:
        displayer.perform_job()
    except KeyboardInterrupt:
        logging.error("Keyboard interrupt." + sys.exc_info()[0])
        logging.error("Exception in user code:")
        logging.error("-" * 60)
        traceback.print_exc(file=sys.stdout)
        logging.error("-" * 60)
